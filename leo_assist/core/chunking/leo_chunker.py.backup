"""Tree-sitter based chunker for Leo programming language.

This module provides a chunker that uses Tree-sitter for accurate parsing of Leo code.
If Tree-sitter is not available, it falls back to a regex-based chunker that looks
for Leo-specific patterns.
"""
import os
import re
import warnings
import uuid
from typing import List, Dict, Any, Optional

# Try to import Tree-sitter, but make it optional
try:
    from tree_sitter import Language, Parser, Node
    TREE_SITTER_AVAILABLE = True
except ImportError:
    TREE_SITTER_AVAILABLE = False
    warnings.warn(
        "Tree-sitter is not installed. Falling back to regex-based Leo chunker. "
        "Install with: pip install tree-sitter"
    )

from .base import Chunk, Chunker, LangChainChunker
from typing import Optional
from src.utils.logger import logger

class TreeSitterLeoChunker(Chunker):
    """Chunker for Leo language using Tree-sitter for accurate parsing.
    
    This chunker uses the Tree-sitter parsing library to understand the structure
    of Leo code, allowing it to create chunks that respect the semantic boundaries
    of the code (functions, structs, programs, etc.).
    
    If Tree-sitter is not available or fails to parse the code, it will fall back
    to a regex-based chunker that looks for Leo-specific patterns.
    
    Example:
        ```python
        chunker = TreeSitterLeoChunker()
        chunks = chunker.chunk(leo_code, {"source": "program.leo"})
        ```
    """
    
    def __init__(self, language: Optional[str] = "leo", chunk_size: int = 1000, overlap: int = 100):
        """Initialize the Tree-sitter based Leo chunker.
        
        Args:
            language: The programming language (defaults to 'leo')
            chunk_size: Target size for chunks
            overlap: Number of characters to overlap between chunks
        """
        super().__init__(language=language, chunk_size=chunk_size, overlap=overlap)
        self.parser = None
        
        if TREE_SITTER_AVAILABLE:
            self._initialize_parser()
    
    def _initialize_parser(self) -> None:
        """Initialize the Tree-sitter parser for Leo."""
        try:
            # Try to load the language from the compiled library
            from tree_sitter_languages import get_language, get_parser
            self.language = get_language("leo")
            self.parser = get_parser("leo")
        except (ImportError, Exception) as e:
            logger.warning(
                f"Failed to load Tree-sitter Leo parser: {str(e)}. "
                "Falling back to regex-based chunking."
            )
            self.language = None
            self.parser = None
    
    def chunk(self, text: str, metadata: Dict[str, Any]) -> List[Chunk]:
        """Chunk Leo code using Tree-sitter for accurate parsing.
        
        Args:
            text: The Leo code to be chunked
            metadata: Metadata to associate with each chunk
            
        Returns:
            List of Chunk objects with preserved Leo structure
        """
        # If Tree-sitter is not available or failed to initialize, fall back to regex
        if not self.parser or not self.language:
            return self._fallback_chunk(text, metadata)
            
        try:
            # Parse the code
            tree = self.parser.parse(bytes(text, 'utf-8'))
            root_node = tree.root_node
            
            # Extract top-level nodes (program, struct, function, etc.)
            chunks = []
            parent_id = metadata.get("parent_id", "root")
            
            # Process each top-level declaration
            for i, node in enumerate(self._get_top_level_nodes(root_node)):
                node_type = node.type
                node_text = text[node.start_byte:node.end_byte].decode('utf-8')
                
                # Get the name of the declaration if available
                name_node = self._get_name_node(node)
                name = name_node.text.decode('utf-8') if name_node else f"unnamed_{i}"
                
                # Create chunk metadata
                chunk_metadata = metadata.copy()
                chunk_metadata.update({
                    'chunk_type': f"leo_{node_type}",
                    'node_type': node_type,
                    'node_name': name,
                    'is_leo_structure': True,
                    'start_line': node.start_point[0],
                    'end_line': node.end_point[0]
                })
                
                chunk = Chunk(
                    id=f"{parent_id}_{node_type}_{name}_{i}",
                    content=node_text,
                    metadata=chunk_metadata,
                    parent_id=parent_id,
                    chunk_index=i,
                    is_complete=True,
                    chunk_type=f"leo_{node_type}"
                )
                chunks.append(chunk)
                
            return chunks
            
        except Exception as e:
            logger.warning(f"Error parsing Leo code with Tree-sitter: {str(e)}. Falling back to regex chunker.")
            return self._fallback_chunk(text, metadata)
    
    def _get_top_level_nodes(self, root_node):
        """Get top-level declaration nodes from the AST."""
        top_level_types = {
            "program_declaration",
            "struct_declaration",
            "record_declaration",
            "mapping_declaration",
            "function_definition",
            "transition_definition",
            "import_declaration",
            "interface_declaration",
            "program_definition"
        }
        
        # Get all nodes that are direct children of the root and have a type we're interested in
        return [
            node for node in root_node.children
            if node.type in top_level_types
        ]
    
    def _get_name_node(self, node):
        """Get the name node from a declaration node."""
        # Different node types have name nodes in different positions
        if node.type in ("function_definition", "transition_definition"):
            # Function/transition name is the first identifier after 'function'/'transition' keyword
            for child in node.children:
                if child.type == "identifier":
                    return child
        elif node.type in ("struct_declaration", "record_declaration", "mapping_declaration"):
            # Name is the first identifier after the declaration keyword
            for child in node.children:
                if child.type == "type_identifier":
                    return child
        return None
    
    def _fallback_chunk(self, text: str, metadata: Dict[str, Any]) -> List[Chunk]:
        """Fallback chunking method when Tree-sitter is not available.
        
        Args:
            text: The Leo code to be chunked
            metadata: Metadata to associate with each chunk
            
        Returns:
            List of Chunk objects with preserved Leo structure
        """
        # Use the dedicated LeoRegexChunker as fallback
        return LeoRegexChunker(
            chunk_size=self.chunk_size,
            overlap=self.overlap
        ).chunk(text, metadata)



    
class LeoRegexChunker(Chunker):
    """Regex-based chunker specifically for Leo programming language.
    
    This chunker uses regex patterns to identify Leo language constructs
    and create meaningful chunks. It's designed to be used as a fallback
    when Tree-sitter is not available.
    
    Example:
        ```python
        chunker = LeoRegexChunker()
        chunks = chunker.chunk(leo_code, {"source": "program.leo"})
        ```
    """
    
    def __init__(self, language: Optional[str] = 'leo', chunk_size: int = 1000, overlap: int = 100):
        """Initialize the regex-based Leo chunker.
        
        Args:
            language: The programming language (defaults to 'leo')
            chunk_size: Target size for chunks
            overlap: Number of characters to overlap between chunks
        """
        super().__init__(language=language, chunk_size=chunk_size, overlap=overlap)
        self._init_patterns()
    
    def _init_patterns(self) -> None:
        """Initialize the regex patterns for Leo code structures."""
        # Patterns for different Leo constructs
        self.patterns = {
            "program": re.compile(
                r'(program\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\{.*?\})(?=\s*(?:program\b|$))',
                re.DOTALL
            ),
            "struct": re.compile(
                r'(struct\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\{.*?\})(?=\s*(?:struct\b|program\b|$))',
                re.DOTALL
            ),
            "record": re.compile(
                r'(record\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\{.*?\})(?=\s*(?:record\b|program\b|$))',
                re.DOTALL
            ),
            "mapping": re.compile(
                r'(mapping\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\{.*?\})(?=\s*(?:mapping\b|program\b|$))',
                re.DOTALL
            ),
            "function": re.compile(
                r'(function\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\([^)]*\)\s*(?:->\s*[a-zA-Z_][a-zA-Z0-9_]*\s*)?\{.*?\})(?=\s*(?:function\b|program\b|$))',
                re.DOTALL
            ),
            "transition": re.compile(
                r'(transition\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\([^)]*\)\s*(?:->\s*\([^)]*\)\s*)?\{.*?\})(?=\s*(?:transition\b|program\b|$))',
                re.DOTALL
            ),
            "import": re.compile(
                r'(import\s+[a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*\s*;)'
            )
        }
    
    def chunk(self, text: str, metadata: Dict[str, Any]) -> List[Chunk]:
        """Chunk Leo code using regex patterns.
        
        Args:
            text: The Leo code to be chunked
            metadata: Metadata to associate with each chunk
            
        Returns:
            List of Chunk objects with preserved Leo structure
        """
        logger.info(f"Chunking Leo code with regex patterns: {text}")

        chunks = []
        parent_id = metadata.get("parent_id", str(uuid.uuid4()))
        
        # First, try to chunk by Leo structures
        for chunk_type, pattern in self.patterns.items():
            for match in pattern.finditer(text):
                chunk_text = match.group(1).strip()
                if not chunk_text:
                    continue
                    
                # Extract name if possible
                name_match = re.search(r'(?:program|struct|record|mapping|function|transition|import)\s+([a-zA-Z_][a-zA-Z0-9_]*)', chunk_text)
                name = name_match.group(1) if name_match else f"unnamed_{len(chunks)}"
                
                # Create chunk metadata
                chunk_metadata = metadata.copy()
                chunk_metadata.update({
                    "node_name": name,
                    "is_leo_structure": True,
                    "line_start": match.start(),
                    "line_end": match.end()
                })
                
                chunk = Chunk(
                    id=f"{parent_id}_{chunk_type}_{name}_{len(chunks)}",
                    content=chunk_text,
                    metadata=chunk_metadata,
                    parent_id=parent_id,
                    chunk_index=len(chunks),
                    is_complete=True,
                    chunk_type=chunk_type
                )

                logger.info(f"Chunked Leo code with regex patterns: {chunk}")

                chunks.append(chunk)
        
        chunks = sorted(chunks, key=lambda x: x.metadata["line_start"])

        # If no Leo structures found, fall back to LangChain chunker
        if not chunks:
            return LangChainChunker(
                chunk_size=self.chunk_size,
                overlap=self.overlap
            ).chunk(text, metadata)
            
        return chunks
